#!/software/bin/perl -w

use strict;
use warnings;
use Carp;
use Tk;
use Tk::widgets qw/JPEG PNG/;
use Tk::Pane;
use FindBin;
use Data::Dumper;

my $opts = parse_params();
init($opts);
run($opts);

exit;

#--------------------------------

sub error
{
    my (@msg) = @_;
    if ( scalar @msg ) { confess @msg; }
    die
        "Usage: lookseq [OPTIONS] <file.bam>\n",
        "Options:\n",
        "   -c, --config <dir>              Where to save temporary data (default is \$HOME/.lookseq).\n",
        "   -r, --reference <file.fa>       The reference fasta file.\n",
        "   -h, -?, --help                  This help message.\n",
        "\n";
}


sub parse_params
{
    my $opts = { config=>"$ENV{HOME}/.lookseq" };
    $$opts{last_state} = "$$opts{config}/last_state";

    while (my $arg=shift(@ARGV))
    {
        if ( $arg eq '-c' || $arg eq '--config' ) { $$opts{config} = shift(@ARGV); next }
        if ( $arg eq '-r' || $arg eq '--reference' ) { $$opts{reference} = shift(@ARGV); next }
        if ( $arg eq '-?' || $arg eq '-h' || $arg eq '--help' ) { error(); }
        if ( -e $arg ) { $$opts{bam} = $arg; next; }
        error("Unknown parameter \"$arg\". Run -h for help.\n");
    }
    $$opts{settings} = "$$opts{config}/settings.pm";

    $$opts{get_data} = "$FindBin::RealBin/../cgi-bin/get_data.pl";
    if ( ! -e $$opts{get_data} ) { error("FIXME: could not find the get_data.pl binary (tried $$opts{get_data})\n"); }
    $$opts{get_data} = "perl -T -I $$opts{config} $$opts{get_data}";

    $$opts{chrom_stats} = "$FindBin::RealBin/../cgi-bin/chromosome_stats.pl";
    if ( ! -e $$opts{chrom_stats} ) { error("FIXME: could not find the chromosome_stats.pl binary (tried $$opts{chrom_stats})\n"); }
    $$opts{chrom_stats} = "perl -T -I $$opts{config} $$opts{chrom_stats}";

    if ( !$$opts{bam} && ! -e "$$opts{config}/file.bam" ) { error("No bam file given?\n"); }
    if ( !$$opts{reference} && ! -e "$$opts{config}/reference.fa" ) { error("Expected the -r option.\n"); }

    return $opts;
}


sub CMD
{
    my ($cmd) = @_;
    print STDERR "$cmd\n";
    my (@out) = `$cmd`;
    if ( $? )
    {
        print STDERR "$?: $!";
    }
    if ( scalar @out ) { return \@out; }
    return undef;
}

sub symlink_binary
{
    my ($dir,$bin) = @_;
    if ( -e "$dir/$bin" ) { return; }

    my $which = CMD("which $bin");
    if ( !$which ) { error("samtools not in the path?\n"); }

    chomp($$which[0]);
    symlink($$which[0], "$dir/$bin");
}

sub symlink_indexed
{
    my ($src,$dst,$idx) = @_;
    if ( -e $dst )
    {
        if ( !-l $dst ) { error("Not removing $dst, not a symlink.\n"); return; }
        unlink($dst);
    }
    if ( -e "$dst$idx" )
    {
        if ( !-l "$dst$idx" ) { error("Not removing $dst$idx, not a symlink.\n"); return; }
        unlink("$dst$idx");
    }

    symlink($src,$dst);
    if ( -e "$src$idx" ) { symlink("$src$idx","$dst$idx"); }
}

sub init
{
    my ($opts) = @_;
    if ( !-e $$opts{config} ) { CMD("mkdir -p $$opts{config}"); }

    symlink_binary($$opts{config}, 'samtools');
    if ( $$opts{reference} ) { symlink_indexed($$opts{reference},"$$opts{config}/reference.fa",'.fai'); }
    if ( $$opts{bam} ) { symlink_indexed($$opts{bam},"$$opts{config}/file.bam",'.bai'); }

    open(my $fh,'>',$$opts{settings}) or error("$$opts{settings}: $!"); 
    print $fh q[
# Do not edit this file, it will be overwritten. Edit the settings.pm-template instead.
package settings;

use Exporter 'import';
our @EXPORT = qw(
    $execpath $datapath $genome_file $reference_fa $webroot $docroot $htmlpath $tooltitle
    $cgi_path $annotation_file $snp_file $robots_flag $use_db_index_cutoff $uniqueness_file
    $use_sanger_cache $use_sanger_layout $sanger_header $css_file
    $use_mysql $mysql_server $mysql_port $mysql_user $mysql_password @mysql_dbs
    $max_window %lscolor $ls_max_lines $bam_ftp $reference_ftp $ensembl_http $render_image_command
);

our %lscolor;
$lscolor{'black'} = [ 0x00 , 0x00 , 0x00 ] ;
$lscolor{'white'} = [ 0xFF , 0xFF , 0xFF ] ;
$lscolor{'ltblue'} = [ 0x44 , 0xB4 , 0xD5 ] ;
$lscolor{'green'} = [ 0x00 , 0xFF , 0x00 ] ;
$lscolor{'green2'} = [ 0x00 , 0x80 , 0x00 ] ;
$lscolor{'ltgreen'} = [ 0x72 , 0xFE , 0x95 ] ;
$lscolor{'yellow'} = [ 0xED , 0xEF , 0x85 ] ;
$lscolor{'ltgrey'} = [ 0xDC , 0xDC , 0xDC ] ;
$lscolor{'grey'} = [ 0xC8 , 0xC8 , 0xC8 ] ;
$lscolor{'cyan'} = [ 0x44 , 0xB4 , 0xD5 ] ; # Cigar

$lscolor{'blue'}         = [0x45, 0x77, 0xa5];    # matching
$lscolor{'red'}          = [0xc3, 0x00, 0x1d];    # SNPs
$lscolor{'black'}        = [0x2f, 0x4f, 0x4f];    # reference
$lscolor{'green2'}       = [0x87, 0xa0, 0x4d];    # single pair
$lscolor{'brown'}        = [0x84, 0x6d, 0x53] ;   # Inversion
$lscolor{'mapqual_zero'} = [0xff, 0x72, 0x00] ;   # mapping quality zero

our $genome_file  = 'reference.fa';
our $reference_fa = 'reference.fa';
];
    print $fh q[our $execpath = '].$$opts{config}.qq[';\n];
    print $fh q[our $datapath = '].$$opts{config}.qq[';\n];
    our $reference_fa = 'reference.fa';
    close($fh);

    read_state($opts);
}

sub read_state
{
    my ($opts) = @_;

    my $saved_opts = do $$opts{last_state};
    if ( ! -e $$opts{last_state} )
    {
        $saved_opts = 
        {
            insert_size => 'Auto',
            width => 700,
            view_mode => 'pileup',
            chr => 1,
            from => 5783647,
            zoom => '100b',
        };
    }
    for my $key qw(insert_size width view_mode chr from zoom)
    {
        if ( exists($$saved_opts{$key}) && defined $$saved_opts{$key} ) { $$opts{$key} = $$saved_opts{$key}; }
    }
}

sub save_state
{
    my ($opts) = @_;
    my $to_save = {};
    for my $key qw(insert_size width view_mode chr from zoom)
    {
        $$to_save{$key} = $$opts{$key};
    }
    open(my $fh,'>',$$opts{last_state}) or error("$$opts{last_state}: $!");
    print $fh Dumper($to_save);
    close $fh;
}

sub strip_http_header
{
    my ($data) = @_;
    while ( !($$data[0]=~/^\s*$/) ) { shift @$data; }
    shift @$data;
}


sub update_to_range
{
    my ($opts) = @_;

    my $to = $$opts{from}+int($$opts{width}/7);
    if ( $$opts{view_mode} ne 'pileup' && $$opts{zoom}=~/^(\d+)([kM]?)b?$/ ) 
    {
        if ( $2 )
        {
            if ( $2 eq 'k' ) { $to = $$opts{from}+$1*1000; }
            elsif ( $2 eq 'M' ) { $to = $$opts{from}+$1*1000000; }
        }
        else
        {
            $to = $$opts{from}+$1;
        }
    }
    $$opts{to} = $to;
}

sub run
{
    my ($opts) = @_;

    update_to_range($opts);
    $$opts{tk_position} = int(($$opts{from}+$$opts{to})*0.5);

    my $mw = MainWindow->new;
    $$opts{tk_window} = $mw;

    # $mw->bind("<Configure>" => [\&configure,$opts]);
    $mw->bind("<Control-q>" => \&exit);
    $mw->bind("<Key-Left>" => [\&move_left,$opts]);
    $mw->bind("<Key-Right>" => [\&move_right,$opts]);

    main_image($opts);

    my %optionmenu_args = ( -borderwidth=>1, -padx=>0, -pady=>0, -relief=>'flat');
    my %entry_args = ( -borderwidth=>1, -relief=>'flat', -highlightbackground=>'#a3a3a3', -takefocus=>0, -insertofftime=>0);
    my %button_args = ( -borderwidth=>1, -relief=>'flat', -highlightbackground=>'#a3a3a3', -padx=>1, -pady=>1 );
    my %label_args = ( );

    $mw->Label(-text=>'   View:')->pack(-side=>'left');
    $mw->Optionmenu(-options=>[qw(pileup reads)], -command=>[\&view_mode,$opts], %optionmenu_args, -textvariable=>\$$opts{view_mode})->pack(-side=>'left');
    $mw->Label(-text=>'   Chr:', %label_args)->pack(-side=>'left');

    my $chr_list = get_chr_list($opts);
    $mw->Optionmenu(-options => $chr_list, -command=>[\&set_chromosome,$opts], %optionmenu_args)->pack(-side=>'left');
    $mw->Label(-text=>'   Pos from:')->pack(-side=>'left');
    $$opts{tk_position_from} = $mw->Entry(-width=>10, %entry_args, -text=>$$opts{from})->pack(-side=>'left');
    $mw->Label(-text=>'   Zoom:', %label_args)->pack(-side=>'left');
    $$opts{tk_zoom} = $mw->Entry(-width=>6, %entry_args, -text=>$$opts{zoom})->pack(-side=>'left');
    $mw->Label(-text=>'   Insert size:', %label_args)->pack(-side=>'left');
    $$opts{tk_insert_size} = $mw->Entry(-width=>6, %entry_args, -text=>$$opts{insert_size})->pack(-side=>'left');

    $mw->Button(-text=>'Refresh' ,-command=>[\&refresh,$opts], %button_args)->pack(-side=>'right');
    $mw->Label(-textvariable=>\$$opts{tk_position})->pack(-side=>'right');

    MainLoop;
}

sub get_chr_list
{
    my ($opts) = @_;
    my $out = CMD("$$opts{chrom_stats}");
    if ( !$out ) { return; }
    strip_http_header($out);
    my @list;
    for my $chr (@$out)
    {
        if ( $chr=~/^(\d+|x|y)\s+/i ) { push @list, $1; }
    }
    return \@list;
}

sub refresh
{
    my ($opts) = @_;

    if ( $$opts{tk_zoom} )
    {
        $$opts{zoom} = $$opts{tk_zoom}->get();
        update_to_range($opts);
    }

    if ( $$opts{tk_insert_size} )
    {
        $$opts{insert_size} = $$opts{tk_insert_size}->get();
    }

    if ( $$opts{tk_position_from} )
    {
        my $from = $$opts{tk_position_from}->get();
        if ( $from && $$opts{from} ne $from ) 
        { 
            $$opts{to}  += $from-$$opts{from};
            $$opts{from} = $from;
        }
    }

    main_image($opts);
}

sub main_image
{
    my ($opts) = @_;

    save_state($opts);

    my $chr  = $$opts{chr};
    my $from = $$opts{from};
    my $to   = $$opts{to};

    my $view = $$opts{view_mode} eq 'pileup' ? 'paired_pileup' : 'indel';
    my $args = qq[output=image width=$$opts{width} view=$view maxdist=$$opts{insert_size} display='|perfect|single|inversions|pairlinks|potsnps|uniqueness|gc|coverage|' debug=0 lane=file.bam];
    my $out = CMD("$$opts{get_data} $args from=$from to=$to chr=$chr");
    if ( !$out ) { return; }

    strip_http_header($out);

    open(my $fh,'>',"$$opts{config}/img.png") or error("$$opts{config}/img.png: $!"); 
    print $fh join('',@$out);
    close($fh);

    if ( $$opts{tk_photo} )
    {
        $$opts{tk_photo}->destroy;
        $$opts{tk_photo}  = $$opts{tk_window}->Photo('main',-file=>"$$opts{config}/img.png",-format=>'PNG');
        $$opts{tk_canvas}->configure(-scrollregion => [ $$opts{tk_canvas}->bbox("all") ]);
    }
    else
    {
        $$opts{tk_photo}  = $$opts{tk_window}->Photo('main',-file=>"$$opts{config}/img.png",-format=>'PNG');
        my $w = $$opts{tk_photo}->width;
        my $h = $$opts{tk_photo}->height + 80;
        $$opts{tk_canvas} = $$opts{tk_window}->Scrolled('Canvas', -scrollbars=>'e', -width=>$w, -height=>$h)->pack(-side=>'bottom',-expand=>1,-fill=>'x');
        $$opts{tk_canvas}->createImage(0,$$opts{tk_photo}->height,-image=>'main',-anchor=>'sw');
        $$opts{tk_canvas}->CanvasBind('<ButtonRelease-1>' => [\&set_position, $opts]);
        $$opts{tk_canvas}->CanvasBind('<Motion>' => [\&set_position, $opts]);
        $$opts{tk_canvas}->CanvasBind('<Double-Button-1>' => [\&move_to_position, $opts]);

        $$opts{width} = $w;
    }

    update_position_entry($opts);
    depth_image($opts);
}

sub depth_image
{
    my ($opts) = @_;

    my $chr  = $$opts{chr};
    my $from = $$opts{from};
    my $to   = $$opts{to};

    my $args = qq[output=image width=$$opts{width} view=coverage maxdist=$$opts{insert_size} display='|perfect|single|inversions|pairlinks|potsnps|uniqueness|gc|coverage|' debug=0 lane=file.bam];
    my $out = CMD("$$opts{get_data} $args from=$from to=$to chr=$chr");
    if ( !$out ) { return; }

    strip_http_header($out);

    open(my $fh,'>',"$$opts{config}/depth.png") or error("$$opts{config}/depth.png: $!"); 
    print $fh join('',@$out);
    close($fh);

    if ( $$opts{tk_depth} )
    {
        $$opts{tk_depth}->destroy;
        $$opts{tk_depth} = $$opts{tk_window}->Photo('depth',-file=>"$$opts{config}/depth.png",-format=>'PNG');
        $$opts{tk_canvas}->configure(-scrollregion => [ $$opts{tk_canvas}->bbox("all") ]);
    }
    else
    {
        $$opts{tk_depth}  = $$opts{tk_window}->Photo('depth',-file=>"$$opts{config}/depth.png",-format=>'PNG');
        my $w = $$opts{width};
        my $h = $$opts{tk_photo}->height + 80;
        $$opts{tk_canvas}->createImage(0,$$opts{tk_photo}->height+80,-image=>'depth',-anchor=>'sw');
        $$opts{tk_canvas}->createLine($w/2,0,$w/2,$h,-fill=>'red',-tag=>'position_line',-dash=>[2,2]);
    }
}



# Handlers...

sub configure
{
    my ($opts) = @_;
    print STDERR "configure\n";
}

sub view_mode
{
    my ($opts,$mode) = @_;
    if ( !$$opts{view_mode} || $$opts{view_mode} ne $mode )
    {
        $$opts{view_mode} = $mode;
        refresh($opts);
    }
    $$opts{view_mode} = $mode;
}

sub move_left
{
    my (@args) = @_;
    my $opts = $args[-1];
    my $delta = int(($$opts{to} - $$opts{from})/3);
    $$opts{from} -= $delta;
    $$opts{to}   -= $delta;
    main_image($opts);
}
sub move_right
{
    my (@args) = @_;
    my $opts = $args[-1];
    my $delta = int(($$opts{to} - $$opts{from})/3);
    $$opts{from} += $delta;
    $$opts{to}   += $delta;
    main_image($opts);
}

sub set_position
{
    my ($widget,$opts) = @_;

    my $e = $widget->XEvent;
    my($X, $Y, $x, $y) = ($e->X, $e->Y, $e->x, $e->y);

    my ($lx,$ly) = $$opts{tk_canvas}->coords('position_line');
    $$opts{tk_canvas}->move('position_line',$x-$lx,0);
    $$opts{tk_position} = int($x*($$opts{to}-$$opts{from}+1)/$$opts{width}) + $$opts{from};
}

sub move_to_position
{
    my ($widget,$opts) = @_;

    my $e = $widget->XEvent;
    my($X, $Y, $x, $y) = ($e->X, $e->Y, $e->x, $e->y);

    my $new_midpoint = int($x*($$opts{to}-$$opts{from}+1)/$$opts{width});
    my $delta = $new_midpoint - int(0.5*($$opts{to}-$$opts{from}));

    $$opts{from} += $delta;
    $$opts{to}   += $delta;

    main_image($opts);
}

sub update_position_entry
{
    my ($opts) = @_;
    if ( $$opts{tk_position_from} )
    {
        $$opts{tk_position_from}->delete(0,'end');
        $$opts{tk_position_from}->insert(0, $$opts{from});
    }
}

sub set_chromosome
{
    my ($opts,$chr) = @_;
    $$opts{chr} = $chr;
}



